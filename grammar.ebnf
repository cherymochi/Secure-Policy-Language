(*
    Secure Policy Language (SPL) - Complete Grammar (EBNF Format)
    University of Technology, Jamaica - CIT4004
    Analysis of Programming Languages Project
    
    Team Members:
    - Javido Robinson - 1707486
    - Athaliah Knight - 1804360
    - Nathalea Evans - 2101707
    - Shemmar Ricketts - 2005329
    
    Notes:
    - Attribute names 'can', 'path', and 'action' are matched case-insensitively
      by the lexer (both 'can'/'CAN', 'path'/'PATH', 'action'/'ACTION' are recognized).
      The grammar shows lowercase for consistency with typical usage.
    - The '*' symbol is tokenized as either WILDCARD or TIMES based on context:
      * WILDCARD: When used in permission contexts (after 'can:', 'action:', 'path:' or inside braces)
      * TIMES: When used in arithmetic expressions (between numbers/identifiers)
      The lexer automatically determines the correct token type during tokenization.
*)

(* ============================================
   TOP LEVEL PROGRAM STRUCTURE
   ============================================ *)
program ::= declaration*

declaration ::= role_def | user_def | resource_def | const_def | call_def | named_policy_def | rule_def

(* ============================================
   ROLE DEFINITIONS
   ============================================ *)
role_def ::= 'ROLE' identifier '{' role_attributes '}'

role_attributes ::= role_attribute (',' role_attribute)*

role_attribute ::= 'can' ':' action_list

action_list ::= wildcard | action_item (',' action_item)*

action_item ::= identifier

wildcard ::= '*'

(* ============================================
   USER DEFINITIONS
   ============================================ *)
user_def ::= 'USER' identifier '{' user_attributes '}'

user_attributes ::= user_attribute (',' user_attribute)*

user_attribute ::= 'role' ':' role_list

role_list ::= identifier (',' identifier)*

(* ============================================
   CONSTANT DEFINITIONS
   ============================================ *)
const_def ::= 'CONST' identifier '=' const_value

const_value ::= number_literal | string_literal

(* ============================================
   CALL STATEMENTS (Query/Debug)
   ============================================ *)
call_def ::= 'CALL' call_type
           | 'CALL' call_type identifier

call_type ::= 'ROLE' | 'RESOURCE' | 'USER' | 'CONST' | 'POLICY'

(* ============================================
   RESOURCE DEFINITIONS
   ============================================ *)
resource_def ::= 'RESOURCE' identifier '{' resource_attributes '}'

resource_attributes ::= resource_attribute (',' resource_attribute)*

resource_attribute ::= 'path' ':' string_literal
                      | identifier ':' resource_value

resource_value ::= string_literal
                  | number_literal
                  | array_literal

array_literal ::= '[' array_elements ']'

array_elements ::= string_literal (',' string_literal)*
                  | (* empty *)

(* ============================================
   STATEMENT (Used in policy bodies)
   ============================================ *)
statement ::= role_def 
            | user_def 
            | resource_def 
            | const_def 
            | call_def 
            | named_policy_def 
            | rule_def

(* ============================================
   NAMED POLICY DEFINITIONS (Function-like)
   ============================================ *)
named_policy_def ::= 'POLICY' identifier '{' policy_body '}'

policy_body ::= statement*
                | (* empty *)

(* ============================================
   POLICY DEFINITIONS (Standalone Rules)
   ============================================ *)
policy_def ::= rule_def

rule_def ::= policy_type action_clause 'ON' resource_clause ('IF' condition)?

policy_type ::= 'ALLOW' | 'DENY'

action_clause ::= 'action' ':' action_list

resource_clause ::= 'resource' ':' resource_path

resource_path ::= identifier | string_literal

(* ============================================
   CONDITIONS AND EXPRESSIONS
   ============================================ *)
condition ::= boolean_expr

boolean_expr ::= boolean_term (('AND' | 'OR') boolean_term)*

boolean_term ::= comparison_expr | '(' boolean_expr ')'

comparison_expr ::= arithmetic_expr comparison_op arithmetic_expr

comparison_op ::= '==' | '!=' | '<' | '>' | '<=' | '>='

(* ============================================
   ARITHMETIC EXPRESSIONS (PEMDAS/BODMAS)
   ============================================ *)
arithmetic_expr ::= term (('+' | '-') term)*

term ::= factor (('*' | '/') factor)*

factor ::= number_literal 
         | identifier 
         | attribute_access 
         | '(' arithmetic_expr ')' 
         | ('+' | '-') factor

attribute_access ::= identifier '.' identifier

(* ============================================
   LITERALS
   ============================================ *)
identifier ::= [a-zA-Z_][a-zA-Z0-9_]*

number_literal ::= digit+

digit ::= [0-9]

string_literal ::= '"' [^"]* '"'

(* ============================================
   COMMENTS
   ============================================ *)
(* 
   Comments are supported in two styles:
   - Single-line: // comment text
   - Multi-line: /* comment text */
   
   Comments are ignored by the lexer and do not affect parsing.
   Multi-line comments can span multiple lines and properly track line numbers.
*)

